/*
VS_ScreenSpaceShadowPOM_Output VertexShaderPOM (VS_ScreenSpaceShadow_Input input)
{
	VS_ScreenSpaceShadowPOM_Output output; 
	
	//
    output.WorldPosition = mul(input.Position, World);
    output.Position = mul(output.WorldPosition, ViewProj);
    
    // TBN SPACE
    
	output.TBN[0] = mul(input.Tangent, World);
    output.TBN[1] = mul(input.Binormal, World);
    output.TBN[2] = mul(input.Normal, World);
    
    //
	//output.TexCoord = input.TexCoord;
	output.TexCoord = input.TexCoord * 2.0;
	
	//
	output.PositionViewS = mul(mul(input.Position, World), View);
	output.CurrPositionCS = output.Position;
	output.PrevPositionCS = mul(input.Position, PrevWorldViewProj);
	
	//
    float4 ShadowMapPos = mul(output.WorldPosition, LightViewProj);
    output.ProjCoord[0] = ShadowMapPos.x / ShadowMapPos.w / 2.0f + 0.5f;
    output.ProjCoord[1] = -ShadowMapPos.y / ShadowMapPos.w / 2.0f + 0.5f;
    
    /////output.ScreenCoord.x = (output.Position.x * 0.5f + output.Position.w * 0.5f);
    /////output.ScreenCoord.y = (output.Position.w * 0.5f - output.Position.y * 0.5f);
    
    //
    output.ScreenCoord.x = 0.5f * (output.Position.x + output.Position.w + 0.25f);
    output.ScreenCoord.y = 0.5f * (output.Position.w - output.Position.y - 0.25f);
    output.ScreenCoord.z = output.Position.w;
    output.ScreenCoord.w = output.Position.w;
	
	//float3 vNormalWS   = mul(Input.Normal, World);
    //float3 vTangentWS  = mul(Input.Tangent, World);
    //float3 vBinormalWS = mul(Input.Binormal, World);
    //Output.vNormalWS = vNormalWS;
    //vNormalWS   = normalize( vNormalWS );
    //vTangentWS  = normalize( vTangentWS );
    //vBinormalWS = normalize( vBinormalWS );
    //float4 vPositionWS = mul( Input.Position, World );
    //Output.vViewWS = vViewWS;
    //Output.dist = length(vLightWS);
    //float3x3 mWorldToTangent = float3x3( vTangentWS, vBinormalWS, vNormalWS );
    
    
    float3 vLightWS = LightPosition.xyz - output.WorldPosition.xyz; //LightDirection;
    float3 vViewWS = CameraPosition.xyz - output.WorldPosition.xyz;
    float3 vLightTS = mul(output.TBN, vLightWS);
    float3 vViewTS  = mul(output.TBN, vViewWS);
    
    float2 vParallaxDirection = normalize(vViewTS.xy);
    float fLength = length(vViewTS);
    float fParallaxLength = sqrt(fLength * fLength - vViewTS.z * vViewTS.z) / vViewTS.z;
    output.vParallaxOffsetTS = vParallaxDirection * fParallaxLength;
    output.vParallaxOffsetTS *= g_fHeightMapScale;
    
	return output;
}

float4 PixelShaderPOM( VS_ScreenSpaceShadowPOM_Output input ) : COLOR0
{   
	float3 vViewWS = normalize(CameraPosition.xyz - input.WorldPosition.xyz);
	//float3 vViewTS  = mul(output.TBN, vViewWS);
	
	float3 vViewTS   = normalize(mul(input.TBN, vViewWS));
	//float3 vViewWS   = normalize(input.vViewWS);
	float3 vLightWS = normalize(LightPosition.xyz - input.WorldPosition.xyz);
	
	float3 vLightTS  = mul(input.TBN, vLightWS);
	float3 vNormalWS = normalize(input.TBN[2]);
    
	float4 cResultColor = float4( 0, 0, 0, 1 );

	float2 dx = ddx( input.TexCoord );
	float2 dy = ddy( input.TexCoord );
    
	int nNumSteps = (int) lerp( g_nMaxSamples, g_nMinSamples, dot( vViewWS, vNormalWS ) );

	float fCurrHeight = 0.0;
	float fStepSize   = 1.0 / (float) nNumSteps;
	float fPrevHeight = 1.0;
	float fNextHeight = 0.0;

	int    nStepIndex = 0;
	bool   bCondition = true;

	float2 vTexOffsetPerStep = fStepSize * input.vParallaxOffsetTS;
	float2 vTexCurrentOffset = input.texCoord;
	float  fCurrentBound     = 1.0;
	float  fParallaxAmount   = 0.0;

	float2 pt1 = 0;
	float2 pt2 = 0;

	float2 texOffset2 = 0;

	while ( nStepIndex < nNumSteps ) 
	{
		vTexCurrentOffset -= vTexOffsetPerStep;

		fCurrHeight = tex2Dgrad( heightSampler, vTexCurrentOffset, dx, dy ).r;

		fCurrentBound -= fStepSize;

		if ( fCurrHeight > fCurrentBound ) 
		{     
			pt1 = float2( fCurrentBound, fCurrHeight );
			pt2 = float2( fCurrentBound + fStepSize, fPrevHeight );

			texOffset2 = vTexCurrentOffset - vTexOffsetPerStep;

			nStepIndex = nNumSteps + 1;
		}
		else
		{
			nStepIndex++;
			fPrevHeight = fCurrHeight;
		}
	}   

	float fDelta2 = pt2.x - pt2.y;
	float fDelta1 = pt1.x - pt1.y;
	fParallaxAmount = (pt1.x * fDelta2 - pt2.x * fDelta1 ) / ( fDelta2 - fDelta1 );
   
	float2 vParallaxOffset = i.vParallaxOffsetTS * (1 - fParallaxAmount );

	float2 texSample = input.texCoord - vParallaxOffset;
	float fOcclusionShadow = 1;
   
	if ( g_bDisplayShadows == true )
	{
		float2 vLightRayTS = vLightTS.xy * g_fHeightMapScale;
	      
		float sh0 =  tex2Dgrad( heightSampler, texSample, dx, dy ).r;
		float shA = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.88, dx, dy ).r - sh0 - 0.88 ) *  1 * g_fShadowSoftening;
		float sh9 = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.77, dx, dy ).r - sh0 - 0.77 ) *  2 * g_fShadowSoftening;
		float sh8 = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.66, dx, dy ).r - sh0 - 0.66 ) *  4 * g_fShadowSoftening;
		float sh7 = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.55, dx, dy ).r - sh0 - 0.55 ) *  6 * g_fShadowSoftening;
		float sh6 = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.44, dx, dy ).r - sh0 - 0.44 ) *  8 * g_fShadowSoftening;
		float sh5 = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.33, dx, dy ).r - sh0 - 0.33 ) * 10 * g_fShadowSoftening;
		float sh4 = (tex2Dgrad( heightSampler, texSample + vLightRayTS * 0.22, dx, dy ).r - sh0 - 0.22 ) * 12 * g_fShadowSoftening;
	   
		fOcclusionShadow = 1 - max( max( max( max( max( max( shA, sh9 ), sh8 ), sh7 ), sh6 ), sh5 ), sh4 );
		fOcclusionShadow = fOcclusionShadow * 0.65 + 0.35; 
	}   
   
	cResultColor = ComputeIllumination( texSample, vLightTS, vViewTS, fOcclusionShadow, input.dist );
	
	return cResultColor;
	
	//return 0;
}


technique POM
{
    pass Pass1
    {
		ZEnable = true;
		ZWriteEnable = true;
		AlphaBlendEnable = false;
		CullMode = CCW;
		AlphaTestEnable = false;
		StencilEnable = true;
		StencilFunc = ALWAYS;
		StencilRef = 1;
		StencilPass = REPLACE;
		StencilZFail = KEEP;
		VertexShader = compile vs_3_0 VertexShaderPOM();
        PixelShader = compile ps_3_0 PixelShaderPOM();
        
        StencilEnable = false;
    }
}
*/